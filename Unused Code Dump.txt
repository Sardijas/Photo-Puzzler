#Unused Code Dump:

#Create destination array

    # resizedOriginal = resizeWinCover(app, app.photoArray)

    # alphaImage = cv.addWeighted(app.winCoverArray, 0.2, resizedOriginal, 0.6, 0, app.stage)

 # for row in blurredImage:
    #     for pixel in row:
    #         pixel.append(0.5)

    #     print(row)


# def cutCounters(app):
#     colorList = []

#     for color in app.palette:
#         colorList.append(color[:4])

#     return colorList

# #Functionality tho
# def resizeWinCover(app, toResize):
#     #Size up??
#     if (len(toResize) > app.height
#         or len(toResize) > app.width):
#         interpolation = cv.INTER_AREA

#     #Size down
#     else:
#         interpolation = cv.INTER_CUBIC

#     #Create destination array
#     app.stage = (app.width, app.height)

#     #Resize image into destination array
#     img = cv.resize(toResize, app.stage, 
#          interpolation)

#     return  img


# flattened_img_array = []
    # for rindex, rows in enumerate(app.photoArray):
    #     for cindex, color in enumerate(rows):
    #         flattened_img_array.append([color[0],color[1],color[2]]) 

    # flattened_img_array = np.array(flattened_img_array)
    # get = split_into_buckets(app, app.photoArray, flattened_img_array, 3)
    # print(get)
    # return get

# red = 0
    # green = 0
    # blue = 0

    # count = 0

    # for pixel in bucket:
    #     red += pixel[0]
    #     green += pixel[1]
    #     blue += pixel[2]

    #     count += 1

    # red //= count
    # green //= count
    # blue //= count


# def getFarthest(palette, n):
#     for color in palette:
#         distance = math.sqrt( (color[0] - red)**2 + (color[1] - green)**2 
#             + (color[2] - blue)**2)

#         if (closestColor == None or distance < closestDistance):
#             closestColor = color
#             closestDistance = distance

#     newColor = rgbToHex(closestColor)
#     app.usedPalette.add(newColor)

# def median_cut_quantize(app, img, img_arr):
#     # when it reaches the end, color quantize
#     r_average = np.mean(img_arr[:,0])
#     g_average = np.mean(img_arr[:,1])
#     b_average = np.mean(img_arr[:,2])
    
#     return [[b_average, g_average, r_average]]
    
# def split_into_buckets(app, img, img_arr, depth):
    
#     if len(img_arr) == 0:
#         return 
        
#     if depth == 0:
#         return median_cut_quantize(app, img, img_arr)
    
#     r_range = np.max(img_arr[:,0]) - np.min(img_arr[:,0])
#     g_range = np.max(img_arr[:,1]) - np.min(img_arr[:,1])
#     b_range = np.max(img_arr[:,2]) - np.min(img_arr[:,2])
    
#     space_with_highest_range = 0

#     if g_range >= r_range and g_range >= b_range:
#         space_with_highest_range = 1
#     elif b_range >= r_range and b_range >= g_range:
#         space_with_highest_range = 2
#     elif r_range >= b_range and r_range >= g_range:
#         space_with_highest_range = 0

    # # sort the image pixels by color space with highest range 
    # # and find the median and divide the array.
    # img_arr = img_arr[img_arr[:,space_with_highest_range].argsort()]
    # median_index = int((len(img_arr)+1)/2)

    
    # #split the array into two blocks
    # return (split_into_buckets(app, img, img_arr[0:median_index], depth-1) + 
    # split_into_buckets(app, img, img_arr[median_index:], depth-1))



# redRange = np.max(bucket[:, 0]) - np.min(bucket[:, 0])
    # greenRange = np.max(bucket[:, 1]) - np.min(bucket[:, 1])
    # blueRange = np.max(bucket[:, 2]) - np.min(bucket[:, 2])

red, green, blue = [None, None], [None, None], [None, None]

    #Longer but more efficient than list comprehensions
    for pixel in bucket:
        if (red[0] == None):
            red[0] = pixel[0]
            red[1] = pixel[0]
        else:
            if (pixel[0] < red[0]):
                red[0] = pixel[0]
            elif (pixel[0] > red[1]):
                red[1] = pixel[0]

        if (green[0] == None):
            green[0] = pixel[1]
            green[1] = pixel[1]
        else:
            if (pixel[1] < green[0]):
                green[0] = pixel[1]
            elif (pixel[1] > green[1]):
                green[1] = pixel[1]

        if (blue[0] == None):
            blue[0] = pixel[2]
            blue[1] = pixel[2]
        else:
            if (pixel[2] < blue[0]):
                blue[0] = pixel[2]
            elif (pixel[2] > blue[1]):
                blue[1] = pixel[2]

    redRange = red[1] - red[0]
    greenRange = green[1] - green[0]
    blueRange = blue[1] - blue[0]

#sortedList = bucket[bucket[:, greatestRange].argsort()]


# blue, green, red, count = 0, 0, 0, 0

    # #numpy for pixel averages - efficient could be complex
    # for row in range(len(cell)):
    #     for col in range(len(cell[0])):
    #         pixel = cell[row][col]
    #         blue += pixel[0]
    #         green += pixel[1]
    #         red += pixel[2]

    #         count += 1

    # blue //= count
    # green //= count
    # red //= count


# def getOddHint(row):
#     hintPriorityList = sorted(row, key=lambda element: element[1])
#     return hintPriorityList[0]


# def trimSolution(app):

#     problems = True

#     while (problems):

#         for i in range(app.rows)


# def trimHints(app):

#     problemRows, problemCols = getProblems(app)
#     problems = True

#     while (problems):

#         fixProblem(app, problemRows[0][0], problemRows[0][1][2], 0)
    
#         fixProblem(app, problemCols[0][0], problemCols[0][1][2], 1)

#         app.hintRows, app.hintCols, app.hRSorted, app.hCSorted = getHints(app)

#         problemRows, problemCols = getProblems(app)

#         if (problemRows == [] and problemCols == []):
#             problems = False
            

            


# def fixProblem(app, row, col, problemDimension):

#     for row in range(app.rows):
#             colContents = []
#             colContents.append(app.solutionGrid[row][col])

#     neighbors = getNeighbors(app, row, col, problemDimension)

#     lastNeighbor = None
#     options = []

#     #Ideally want new color to be in both col and row
#     for neighbor in neighbors:
#         if (neighbor in app.solutionGrid[row] and neighbor in colContents):
#             options.append(neighbor)

#         if (neighbor != app.solutionGrid[row][col]):
#             lastNeighbor = neighbor

#     #Worst case 
#     if (options == []):
#         options.append(lastNeighbor)

#     print(app.solutionGrid[row][col], options[0])
#     app.solutionGrid[row][col] = options[0]
#     print(app.solutionGrid[row][col] )




# def getProblems(app):
#     problemRows = []
#     problemCols = []

#     for i in range(len(app.hintRows)):
#         if (len(app.hintRows[i]) > 5):
#             oddRowCopy = copy.copy(app.hintRows[i])
#             for j in range(len(app.hintRows[i]) - 5):
#                 oddHint = getOddHint(oddRowCopy)
#                 problemRows.append((i, oddHint))
#                 oddRowCopy.remove(oddHint)

    
#     for i in range(len(app.hintCols)):
#         if (len(app.hintCols[i]) > 4):
#             oddColCopy = copy.copy(app.hintCols[i])
#             for j in range(len(app.hintCols[i]) - 4):
#                 oddHint = getOddHint(oddColCopy)
#                 problemCols.append((i, oddHint))
#                 oddColCopy.remove(oddHint)

#     return problemRows, problemCols

# def getNeighbors(app, row, col, problemDimension): 
#     rowNeighbors = set([])
#     colNeighbors = set([])

#     if (row - 1 > 0):
#         rowNeighbors.add(app.solutionGrid[row - 1][col])

#     if (row + 1 < app.rows):
#         rowNeighbors.add(app.solutionGrid[row + 1][col])

#     if (col - 1 > 0):
#         colNeighbors.add(app.solutionGrid[row][col - 1])

#     if (col + 1 > 0):
#         colNeighbors.add(app.solutionGrid[row][col + 1])

#     #https://www.w3schools.com/python/python_ref_set.asp
#     idealNeighbors = rowNeighbors.intersection(colNeighbors)

#     #Ideally return double neighbors
#     if (len(idealNeighbors) != 0):
#         return idealNeighbors
#     #Else return row neighbors
#     else:
#         if (problemDimension == 0):
#             return rowNeighbors
#         else:
#             return colNeighbors

#     # for problemHint in problemRows:
#     #     #My thought is change to a neighboring color that is in both row and col
